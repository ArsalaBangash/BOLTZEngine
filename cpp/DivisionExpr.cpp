////  DivisionExpr.cpp//  Boltz////  Created by KyoKeun Park on 2018-04-02.//  Copyright Â© 2018 KyoKeun Park. All rights reserved.//#include "DivisionExpr.hpp"#include "EngineUtils.hpp"#include <cmath>void DivisionExpr::setMax(Level level) {    switch (level) {        case Level::Basic :            MIN = 1;            MAX = 5;            break;        case Level::Normal :            MIN = 2;            MAX = 10;            break;        case Level::Advanced :            MIN = 2;            MAX = 13;            break;    }}void DivisionExpr::addZeroBoundTokens(SubExprLocation subExprLocation) {    int operand1 = 0;    int operand2 = generatePositiveRandom(MAX) + 1;    switch (subExprLocation) {        case SubExprLocation::NEITHER :            expression.emplace_back(ExprToken(operand1));            expression.emplace_back(ExprToken(operand2));            break;        case SubExprLocation::BOTH :            expression.emplace_back(ExprToken(operand1, true));            expression.emplace_back(ExprToken(operand2, true));            break;        case SubExprLocation::RIGHT :            expression.emplace_back(ExprToken(operand1, true));            expression.emplace_back(ExprToken(operand2));            break;        case SubExprLocation::LEFT :            expression.emplace_back(ExprToken(operand1));            expression.emplace_back(ExprToken(operand2, true));            break;    }}int DivisionExpr::generateDivisor(int bound) {    if (fabs(bound) > MAX * MAX) return 2;    else return (int) random(0, static_cast<int>(MAX * MAX / fabs(bound))) + 1;}void DivisionExpr::noSubExpressions() {    if (this->isBounded) {        int divisor = generateDivisor(bound);        expression.emplace_back(bound * divisor);        expression.emplace_back(ExprToken(divisor));    } else {        int quotient = generatePositiveRandom(MIN, MAX);        int divisor = generatePositiveRandom(MIN, MAX);        expression.emplace_back(ExprToken(quotient * divisor));        expression.emplace_back(ExprToken(divisor));    }}void DivisionExpr::twoSubExpressions() {    if (this->isBounded) {        int divisor = generateDivisor(bound);        expression.emplace_back(ExprToken(bound * divisor, true));        expression.emplace_back(ExprToken(divisor, true));    } else {        int quotient = generatePositiveRandom(MIN, MAX);        int divisor = generatePositiveRandom(MIN, MAX);        expression.emplace_back(ExprToken(quotient * divisor, true));        expression.emplace_back(ExprToken(divisor, true));    }}void DivisionExpr::oneSubExpression(SubExprLocation subExprLocation) {    switch (subExprLocation) {        case SubExprLocation::LEFT :            if (this->isBounded) {                int divisor = generateDivisor(bound);                expression.emplace_back(ExprToken(bound * divisor, true));                expression.emplace_back(ExprToken(divisor));            } else {                int quotient = generatePositiveRandom(MIN, MAX);                int divisor = generatePositiveRandom(MIN, MAX);                expression.emplace_back(ExprToken(quotient * divisor, true));                expression.emplace_back(ExprToken(divisor));            }            break;        case SubExprLocation::RIGHT :            if (this->isBounded) {                int divisor = generateDivisor(bound);                expression.emplace_back(ExprToken(bound * divisor));                expression.emplace_back(ExprToken(divisor, true));            } else {                int quotient = generatePositiveRandom(MIN, MAX);                int divisor = generatePositiveRandom(MIN, MAX);                expression.emplace_back(ExprToken(quotient * divisor));                expression.emplace_back(ExprToken(divisor, true));            }            break;        case NEITHER:            break;        case BOTH:            break;    }}